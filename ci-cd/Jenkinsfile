import jenkins.model.*
import com.cloudbees.plugins.credentials.*
import com.cloudbees.plugins.credentials.domains.*

pipeline {
    agent any

    parameters {
        credentials(name: 'DOCKER_CREDENTIALS', description: 'Select Docker Hub credentials (optional, auto-detected if empty)', required: false)
    }

    environment {
        IMAGE_TAG        = "${env.BUILD_ID}"
        HELM_CHART_PATH  = "helm/app-chart"
        NAMESPACE        = "observability"
        KUBECONFIG_PATH  = "C:\\ProgramData\\Jenkins\\.kube\\config"
    }

    stages {

        stage('1. Code Checkout') {
            steps {
                echo "‚úÖ Code checkout done."
            }
        }

        stage('2. Build & Push Dynamic Docker Image') {
            steps {
                script {
                    def dockerCred = params.DOCKER_CREDENTIALS
                    if (!dockerCred) {
                        def creds = Jenkins.instance
                            .getExtensionList('com.cloudbees.plugins.credentials.SystemCredentialsProvider')[0]
                            .getCredentials()
                        def match = creds.find { it.description?.toLowerCase()?.contains('docker') || it.id?.toLowerCase()?.contains('docker') }
                        dockerCred = match?.id
                        if (!dockerCred) {
                            error "‚ùå No Docker credentials found in Jenkins. Please add or select one."
                        } else {
                            echo "‚úÖ Auto-detected Docker credentials: ${dockerCred}"
                        }
                    }

                    withCredentials([usernamePassword(
                        credentialsId: dockerCred,
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {

                        def dynamicImage = "${DOCKER_USER}/cloud-native-test-app"
                        echo "üß© Using dynamic image repository: ${dynamicImage}"

                        dir('test-app') {
                            bat "docker build -t ${dynamicImage}:${IMAGE_TAG} ."
                        }

                        bat "echo %DOCKER_PASS% | docker login -u %DOCKER_USER% --password-stdin"
                        bat "docker push ${dynamicImage}:${IMAGE_TAG}"

                        env.DOCKER_IMAGE = dynamicImage
                    }
                }
            }
        }

        stage('3. Helm Lint') {
            steps {
                dir('helm/app-chart') {
                    bat "helm lint ."
                }
            }
        }

        stage('4. Kubernetes Cluster Setup & Check') {
            steps {
                script {
                    echo "üîç Checking Minikube and kubectl status..."
                    def kubeconfigExists = fileExists(env.KUBECONFIG_PATH)
                    def kubectlExists = bat(returnStatus: true, script: 'where kubectl') == 0
                    def minikubeExists = bat(returnStatus: true, script: 'where minikube') == 0

                    if (!kubectlExists) error "‚ùå kubectl not found. Install kubectl and restart Jenkins."
                    if (!minikubeExists) error "‚ùå Minikube not found. Install Minikube and restart Jenkins."
                    if (!kubeconfigExists) error "‚ùå Jenkins kubeconfig missing. Copy Minikube config to ${env.KUBECONFIG_PATH}."

                    echo "üß† Checking if Minikube is running..."
                    def minikubeStatus = bat(returnStdout: true, script: "minikube status").trim()

                    if (!minikubeStatus.contains("Running")) {
                        echo "‚öôÔ∏è Minikube is not running ‚Äî starting now..."
                        bat "minikube start --driver=docker"
                    } else {
                        echo "‚úÖ Minikube is already running."
                    }

                    echo "üîó Verifying cluster access..."
                    def checkCluster = bat(returnStatus: true, script: "kubectl get nodes --kubeconfig=${env.KUBECONFIG_PATH}")
                    if (checkCluster != 0) {
                        error "‚ùå Unable to connect to Minikube cluster. Check Docker or Kubernetes setup."
                    } else {
                        echo "‚úÖ Cluster connectivity confirmed."
                    }
                }
            }
        }

        stage('5. Deploy Observability Stack & App') {
            steps {
                withEnv(["KUBECONFIG=${env.KUBECONFIG_PATH}"]) {
                    echo "--- Ensuring Namespace ---"
                    bat "kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f - --validate=false"

                    echo "--- Adding Helm Repositories ---"
                    bat "helm repo add elastic https://helm.elastic.co --force-update"
                    bat "helm repo add bitnami https://charts.bitnami.com/bitnami --force-update"
                    bat "helm repo add grafana https://grafana.github.io/helm-charts --force-update"
                    bat "helm repo update"

                    echo "--- Deploying Elasticsearch ---"
                    bat """
                    helm upgrade --install elasticsearch elastic/elasticsearch ^
                    -f helm/observability/elasticsearch-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 10m
                    """

                    echo "--- Deploying Fluentd ---"
                    bat """
                    helm upgrade --install fluentd bitnami/fluentd ^
                    -f helm/observability/fluentd-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- Deploying Kibana ---"
                    bat """
                    helm upgrade --install kibana elastic/kibana ^
                    -f helm/observability/kibana-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- Deploying Grafana ---"
                    bat """
                    helm upgrade --install grafana grafana/grafana ^
                    -f helm/observability/grafana-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- Deploying Application ---"
                    bat """
                    helm upgrade --install test-app-release ${HELM_CHART_PATH} ^
                    --set image.repository=${env.DOCKER_IMAGE} ^
                    --set image.tag=${IMAGE_TAG} ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- ‚úÖ Deployment Complete. Listing Pods ---"
                    bat "kubectl get pods -n ${NAMESPACE}"

                    echo "üåç Access Dashboards:"
                    echo "  - Kibana: Run 'minikube service kibana -n ${NAMESPACE}'"
                    echo "  - Grafana: Run 'minikube service grafana -n ${NAMESPACE}'"
                    echo "  - App: Run 'minikube service test-app-release -n ${NAMESPACE}'"
                }
            }
        }

        stage('6. Observation Window (30 Minutes)') {
            steps {
                echo "‚è≥ Environment live for 30 minutes. Access dashboards using Minikube service commands."
                echo "üìä You can view logs, metrics, and dashboards in Kibana or Grafana."
                echo "üïí Automatic cleanup will start after 30 minutes..."
                sleep(time: 30, unit: "MINUTES")
            }
        }

        stage('7. Automatic Cleanup') {
            steps {
                withEnv(["KUBECONFIG=${env.KUBECONFIG_PATH}"]) {
                    echo "üßπ Starting cleanup of Helm releases and namespace..."
                    bat "helm uninstall test-app-release -n ${NAMESPACE} || echo 'App not found'"
                    bat "helm uninstall kibana -n ${NAMESPACE} || echo 'Kibana not found'"
                    bat "helm uninstall fluentd -n ${NAMESPACE} || echo 'Fluentd not found'"
                    bat "helm uninstall elasticsearch -n ${NAMESPACE} || echo 'Elasticsearch not found'"
                    bat "helm uninstall grafana -n ${NAMESPACE} || echo 'Grafana not found'"
                    bat "kubectl delete namespace ${NAMESPACE} --ignore-not-found"
                    echo "‚úÖ Cleanup complete. Environment resources released."
                }
            }
        }
    }

    post {
        always {
            echo "üèÅ Pipeline finished."
        }
    }
}
