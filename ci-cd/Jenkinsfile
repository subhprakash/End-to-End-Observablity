import jenkins.model.*
import com.cloudbees.plugins.credentials.*
import com.cloudbees.plugins.credentials.domains.*

pipeline {
    agent any

    parameters {
        credentials(name: 'DOCKER_CREDENTIALS', description: 'Select Docker Hub credentials (optional, auto-detected if empty)', required: false)
        string(name: 'OBSERVATION_MINUTES', defaultValue: '30', description: 'How long (in minutes) the environment should stay live before auto-cleanup')
    }

    environment {
        IMAGE_TAG        = "${env.BUILD_ID}"
        HELM_CHART_PATH  = "helm/app-chart"
        NAMESPACE        = "observability"
        KUBECONFIG_PATH  = "C:\\ProgramData\\Jenkins\\.kube\\config"
        SUMMARY_FILE     = "pipeline_summary.txt"
        START_TIME       = ""
    }

    stages {

        stage('1. Code Checkout') {
            steps {
                script {
                    env.START_TIME = new Date().format("yyyy-MM-dd HH:mm:ss")
                    echo "âœ… Code checkout done at ${env.START_TIME}"
                }
            }
        }

        stage('2. Build & Push Docker Image') {
            steps {
                script {
                    // Directly use credentials set in Jenkins (no getInstance)
                    withCredentials([usernamePassword(
                        credentialsId: 'docker-hub-creds', // replace with your actual ID in Jenkins
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {

                        def dynamicImage = "${DOCKER_USER}/cloud-native-test-app"
                        echo "ğŸ§© Using Docker repository: ${dynamicImage}"

                        dir('test-app') {
                            bat "docker build -t ${dynamicImage}:${IMAGE_TAG} ."
                        }

                        echo "ğŸ” Logging into Docker Hub..."
                        bat """
                        docker logout || echo "no previous login"
                        docker login -u %DOCKER_USER% -p %DOCKER_PASS%
                        """

                        echo "ğŸš€ Pushing Docker image..."
                        bat "docker push ${dynamicImage}:${IMAGE_TAG}"

                        env.DOCKER_IMAGE = dynamicImage
                        echo "âœ… Docker image pushed successfully: ${dynamicImage}:${IMAGE_TAG}"
                    }
                }
            }
        }


        stage('3. Helm Lint') {
            steps {
                dir('helm/app-chart') {
                    bat "helm lint ."
                }
            }
        }

        stage('4. Kubernetes Cluster Setup & Check') {
            steps {
                script {
                    echo "ğŸ” Checking Minikube, kubectl, and kubeconfig..."

                    def kubectlExists = bat(returnStatus: true, script: 'where kubectl') == 0
                    def minikubeExists = bat(returnStatus: true, script: 'where minikube') == 0

                    if (!kubectlExists) error "âŒ kubectl not found. Install kubectl and restart Jenkins."
                    if (!minikubeExists) error "âŒ Minikube not found. Install Minikube and restart Jenkins."

                    echo "ğŸ§  Checking Minikube status..."
                    def status = bat(returnStdout: true, script: "minikube status || exit 0").trim()

                    if (status.contains("does not exist") || !status.contains("Running")) {
                        echo "âš ï¸ Detected broken Minikube profile â€” cleaning up..."
                        bat "minikube delete --all --purge || echo 'Nothing to delete'"
                    }

                    echo "ğŸš€ Starting fresh Minikube cluster..."
                    def startCode = bat(returnStatus: true, script: "minikube start --driver=docker --force --cpus=3 --memory=6000 --kubernetes-version=v1.34.0")
                    if (startCode != 0) error "âŒ Minikube failed to start."

                    def userKubePath = "${env.USERPROFILE}\\.kube\\config"
                    def jenkinsKubeDir = "C:\\ProgramData\\Jenkins\\.kube"
                    def jenkinsKubePath = "${jenkinsKubeDir}\\config"

                    bat """
                    if not exist "${jenkinsKubeDir}" mkdir "${jenkinsKubeDir}"
                    if exist "${userKubePath}" copy /Y "${userKubePath}" "${jenkinsKubePath}"
                    """

                    echo "ğŸ”— Verifying cluster connectivity..."
                    def checkCluster = bat(returnStatus: true, script: "kubectl get nodes --kubeconfig=${jenkinsKubePath}")
                    if (checkCluster != 0) error "âŒ Cluster unreachable after startup."
                    else echo "âœ… Cluster connectivity confirmed."
                }
            }
        }

        stage('5. Deploy Observability Stack & App') {
            steps {
                withEnv(["KUBECONFIG=${env.KUBECONFIG_PATH}"]) {
                    echo "ğŸš€ Deploying Observability Stack + Application..."

                    bat "kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f - --validate=false"

                    echo "--- Adding Helm Repositories ---"
                    bat "helm repo add elastic https://helm.elastic.co --force-update"
                    bat "helm repo add fluent https://fluent.github.io/helm-charts --force-update"
                    bat "helm repo add grafana https://grafana.github.io/helm-charts --force-update"
                    bat "helm repo update"

                    echo "--- Deploying Elasticsearch ---"
                    bat """
                    helm upgrade --install elasticsearch elastic/elasticsearch ^
                    -f helm/observability/elasticsearch-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 10m
                    """

                    echo "--- Deploying Fluent Bit ---"
                    bat """
                    helm upgrade --install fluent-bit fluent/fluent-bit ^
                    -f helm/observability/fluentbit-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- Deploying Kibana ---"
                    bat """
                    helm upgrade --install kibana elastic/kibana ^
                    -f helm/observability/kibana-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- Deploying Grafana ---"
                    bat """
                    helm upgrade --install grafana grafana/grafana ^
                    -f helm/observability/grafana-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- Deploying Application ---"
                    bat """
                    helm upgrade --install test-app-release ${HELM_CHART_PATH} ^
                    --set image.repository=${env.DOCKER_IMAGE} ^
                    --set image.tag=${IMAGE_TAG} ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- âœ… Deployment Complete ---"
                    bat "kubectl get pods -n ${NAMESPACE}"
                }
            }
        }

        stage('6. Observation Window') {
            steps {
                echo "â³ Keeping environment live for ${params.OBSERVATION_MINUTES} minutes..."
                sleep(time: params.OBSERVATION_MINUTES.toInteger(), unit: "MINUTES")
            }
        }

        stage('7. Full Cleanup') {
            steps {
                withEnv(["KUBECONFIG=${env.KUBECONFIG_PATH}"]) {
                    echo "ğŸ§¹ Cleaning up cluster and resources..."
                    bat "helm uninstall test-app-release -n ${NAMESPACE} || echo 'App not found'"
                    bat "helm uninstall kibana -n ${NAMESPACE} || echo 'Kibana not found'"
                    bat "helm uninstall fluent-bit -n ${NAMESPACE} || echo 'Fluent Bit not found'"
                    bat "helm uninstall elasticsearch -n ${NAMESPACE} || echo 'Elasticsearch not found'"
                    bat "helm uninstall grafana -n ${NAMESPACE} || echo 'Grafana not found'"
                    bat "kubectl delete namespace ${NAMESPACE} --ignore-not-found"
                    bat "minikube stop || echo 'Minikube not running'"
                    bat "minikube delete --all --purge || echo 'No clusters to delete'"
                    echo "âœ… Cleanup complete."
                }
            }
        }

        stage('8. Generate Summary Report') {
            steps {
                script {
                    def endTime = new Date().format("yyyy-MM-dd HH:mm:ss")
                    def summary = """
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“˜ PIPELINE SUMMARY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ‘¤ User: ${currentBuild.getBuildCauses()[0].userName ?: "Manual Trigger"}
ğŸ Build ID: ${env.BUILD_ID}
ğŸ•’ Started: ${env.START_TIME}
ğŸ•“ Ended:   ${endTime}
ğŸ“¦ Docker Image: ${env.DOCKER_IMAGE}:${env.IMAGE_TAG}
â˜ï¸ Namespace: ${env.NAMESPACE}
ğŸ§­ Observation Time: ${params.OBSERVATION_MINUTES} minutes
ğŸ’¥ Cleanup: Minikube cluster deleted successfully
âœ… Status: ${currentBuild.currentResult}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"""
                    writeFile file: env.SUMMARY_FILE, text: summary
                    echo summary
                    archiveArtifacts artifacts: env.SUMMARY_FILE, onlyIfSuccessful: true
                }
            }
        }
    }

    post {
        always {
            echo "ğŸ Pipeline finished."
        }
    }
}
