import jenkins.model.*
import com.cloudbees.plugins.credentials.*
import com.cloudbees.plugins.credentials.domains.*

pipeline {
    agent any

    parameters {
        credentials(name: 'DOCKER_CREDENTIALS', description: 'Select Docker Hub credentials (optional, auto-detected if empty)', required: false)
        string(name: 'OBSERVATION_MINUTES', defaultValue: '30', description: 'Duration (in minutes) for which the environment should remain live before cleanup')
    }

    environment {
        IMAGE_TAG        = "${env.BUILD_ID}"
        HELM_CHART_PATH  = "helm/app-chart"
        NAMESPACE        = "observability"
        KUBECONFIG_PATH  = "C:\\ProgramData\\Jenkins\\.kube\\config"
        SUMMARY_FILE     = "pipeline_summary.txt"
        START_TIME       = ""
    }

    stages {

        stage('1. Code Checkout') {
            steps {
                script {
                    env.START_TIME = new Date().format("yyyy-MM-dd HH:mm:ss")
                    echo "âœ… Code checkout done at ${env.START_TIME}"
                }
            }
        }

        stage('2. Build & Push Dynamic Docker Image') {
            steps {
                script {
                    def dockerCred = params.DOCKER_CREDENTIALS
                    if (!dockerCred) {
                        def creds = Jenkins.instance
                            .getExtensionList('com.cloudbees.plugins.credentials.SystemCredentialsProvider')[0]
                            .getCredentials()
                        def match = creds.find { it.description?.toLowerCase()?.contains('docker') || it.id?.toLowerCase()?.contains('docker') }
                        dockerCred = match?.id
                        if (!dockerCred) {
                            error "âŒ No Docker credentials found in Jenkins. Please add or select one."
                        } else {
                            echo "âœ… Auto-detected Docker credentials: ${dockerCred}"
                        }
                    }

                    withCredentials([usernamePassword(
                        credentialsId: dockerCred,
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {

                        def dynamicImage = "${DOCKER_USER}/cloud-native-test-app"
                        echo "ğŸ§© Using dynamic image repository: ${dynamicImage}"

                        dir('test-app') {
                            bat "docker build -t ${dynamicImage}:${IMAGE_TAG} ."
                        }

                        bat "echo %DOCKER_PASS% | docker login -u %DOCKER_USER% --password-stdin"
                        bat "docker push ${dynamicImage}:${IMAGE_TAG}"

                        env.DOCKER_IMAGE = dynamicImage
                    }
                }
            }
        }

        stage('3. Helm Lint') {
            steps {
                dir('helm/app-chart') {
                    bat "helm lint ."
                }
            }
        }

        stage('4. Kubernetes Cluster Setup & Check') {
            steps {
                script {
                    echo "ğŸ” Checking Minikube, kubectl, and kubeconfig..."

                    def kubectlExists = bat(returnStatus: true, script: 'where kubectl') == 0
                    def minikubeExists = bat(returnStatus: true, script: 'where minikube') == 0

                    if (!kubectlExists) error "âŒ kubectl not found. Install kubectl and restart Jenkins."
                    if (!minikubeExists) error "âŒ Minikube not found. Install Minikube and restart Jenkins."

                    echo "ğŸ§  Checking if Minikube is running..."
                    def minikubeStatus = bat(returnStdout: true, script: "minikube status || exit 0").trim()

                    if (!minikubeStatus.contains("Running")) {
                        echo "âš™ï¸ Starting Minikube cluster..."
                        bat "minikube start --driver=docker --force --cpus=4 --memory=7500 --kubernetes-version=v1.34.0"
                    } else {
                        echo "âœ… Minikube is already running."
                    }

                    // --- AUTO-COPY kubeconfig TO JENKINS ---
                    def userKubePath = "${System.getenv('USERPROFILE')}\\.kube\\config"
                    def jenkinsKubeDir = "C:\\ProgramData\\Jenkins\\.kube"
                    def jenkinsKubePath = "${jenkinsKubeDir}\\config"

                    bat """
                    if not exist "${jenkinsKubeDir}" mkdir "${jenkinsKubeDir}"
                    if exist "${userKubePath}" (
                        copy /Y "${userKubePath}" "${jenkinsKubePath}"
                        echo âœ… Copied kubeconfig to Jenkins directory.
                    ) else (
                        echo âš ï¸ Warning: User kubeconfig not found at ${userKubePath}
                    )
                    """

                    echo "ğŸ”— Verifying cluster connectivity..."
                    def checkCluster = bat(returnStatus: true, script: "kubectl get nodes --kubeconfig=${jenkinsKubePath}")

                    if (checkCluster != 0) {
                        echo "âš ï¸ Cluster seems unreachable â€” resetting Minikube..."
                        bat "minikube delete --all || echo 'No clusters found to delete'"
                        bat "minikube start --driver=docker --force --cpus=4 --memory=7500 --kubernetes-version=v1.34.0"
                        bat """
                        if exist "${userKubePath}" (
                            copy /Y "${userKubePath}" "${jenkinsKubePath}"
                        )
                        """
                        checkCluster = bat(returnStatus: true, script: "kubectl get nodes --kubeconfig=${jenkinsKubePath}")
                        if (checkCluster != 0) error "âŒ Failed to connect to Minikube even after reset."
                        else echo "âœ… Minikube recreated and verified."
                    } else {
                        echo "âœ… Cluster connectivity confirmed."
                    }
                }
            }
        }

        stage('5. Deploy Observability Stack & Application') {
            steps {
                withEnv(["KUBECONFIG=${env.KUBECONFIG_PATH}"]) {
                    echo "ğŸš€ Deploying Observability Stack + Application..."

                    bat "kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f - --validate=false"

                    echo "--- Adding Helm Repositories ---"
                    bat "helm repo add elastic https://helm.elastic.co --force-update"
                    bat "helm repo add bitnami https://charts.bitnami.com/bitnami --force-update"
                    bat "helm repo add grafana https://grafana.github.io/helm-charts --force-update"
                    bat "helm repo update"

                    echo "--- Deploying Elasticsearch ---"
                    bat """
                    helm upgrade --install elasticsearch elastic/elasticsearch ^
                    -f helm/observability/elasticsearch-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 10m
                    """

                    echo "--- Deploying Fluentd ---"
                    bat """
                    helm upgrade --install fluentd bitnami/fluentd ^
                    -f helm/observability/fluentd-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- Deploying Kibana ---"
                    bat """
                    helm upgrade --install kibana elastic/kibana ^
                    -f helm/observability/kibana-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- Deploying Grafana ---"
                    bat """
                    helm upgrade --install grafana grafana/grafana ^
                    -f helm/observability/grafana-values.yaml ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- Deploying Application ---"
                    bat """
                    helm upgrade --install test-app-release ${HELM_CHART_PATH} ^
                    --set image.repository=${env.DOCKER_IMAGE} ^
                    --set image.tag=${IMAGE_TAG} ^
                    -n ${NAMESPACE} ^
                    --wait --timeout 5m
                    """

                    echo "--- âœ… Deployment Complete ---"
                    bat "kubectl get pods -n ${NAMESPACE}"

                    echo """
ğŸŒ Access Dashboards:
  - Kibana:  minikube service kibana -n ${NAMESPACE}
  - Grafana: minikube service grafana -n ${NAMESPACE}
  - App:     minikube service test-app-release -n ${NAMESPACE}
                    """
                }
            }
        }

        stage('6. Observation Window (Configurable)') {
            steps {
                echo "â³ Environment is live for ${params.OBSERVATION_MINUTES} minutes..."
                sleep(time: params.OBSERVATION_MINUTES.toInteger(), unit: "MINUTES")
            }
        }

        stage('7. Full Cleanup (Namespace + Minikube Cluster)') {
            steps {
                withEnv(["KUBECONFIG=${env.KUBECONFIG_PATH}"]) {
                    echo "ğŸ§¹ Cleaning up Helm releases, namespace, and Minikube cluster..."

                    bat "helm uninstall test-app-release -n ${NAMESPACE} || echo 'App not found'"
                    bat "helm uninstall kibana -n ${NAMESPACE} || echo 'Kibana not found'"
                    bat "helm uninstall fluentd -n ${NAMESPACE} || echo 'Fluentd not found'"
                    bat "helm uninstall elasticsearch -n ${NAMESPACE} || echo 'Elasticsearch not found'"
                    bat "helm uninstall grafana -n ${NAMESPACE} || echo 'Grafana not found'"
                    bat "kubectl delete namespace ${NAMESPACE} --ignore-not-found"

                    echo "ğŸ§¨ Stopping and deleting Minikube cluster..."
                    bat "minikube stop || echo 'Minikube not running'"
                    bat "minikube delete --all || echo 'No clusters to delete'"

                    echo "âœ… Full cleanup complete."
                }
            }
        }

        stage('8. Generate Summary Report') {
            steps {
                script {
                    def endTime = new Date().format("yyyy-MM-dd HH:mm:ss")

                    def summary = """
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“˜ PIPELINE EXECUTION SUMMARY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ‘¤ User: ${currentBuild.getBuildCauses()[0].userName ?: "Manual Trigger"}
ğŸ Build ID: ${env.BUILD_ID}
ğŸ•’ Started: ${env.START_TIME}
ğŸ•“ Ended:   ${endTime}
ğŸ“¦ Docker Image: ${env.DOCKER_IMAGE}:${env.IMAGE_TAG}
â˜ï¸  Namespace: ${env.NAMESPACE}
ğŸ§­ Observation Time: ${params.OBSERVATION_MINUTES} minutes
ğŸ’¥ Cleanup: Minikube cluster deleted successfully
âœ… Status: ${currentBuild.currentResult}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"""

                    writeFile file: env.SUMMARY_FILE, text: summary
                    echo summary
                    archiveArtifacts artifacts: env.SUMMARY_FILE, onlyIfSuccessful: true
                }
            }
        }
    }

    post {
        always {
            echo "ğŸ Pipeline finished."
        }
    }
}
